package main

/*
 * We need at least a basic backend to serve both our
 * single page (SPA) and data files/CSS/images/etc.
 *
 * We'll later extend this to build our authentication.
 *
 * For now, the configuration (config.json) is somewhat
 * clumsily generated by bin/mkconfigjs.sh.
 */

import (
	"encoding/json"
	"flag"
	"html/template"
	"io"
	"log"
	"net"
	"net/http"
	"net/http/fcgi"
	"os"
	"path/filepath"
	"strings"
	"os/signal"
	"syscall"
)

type Config struct {
	Version string `json:"version"`
	Root    string `json:"root"`
}

var C Config

var indexPageTmpl = template.Must(template.New("").Parse(""+
`<!DOCTYPE html>
<html>
	<head>
		<!-- Google tag (gtag.js) -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-CR2JJD19S0"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag(){dataLayer.push(arguments);}
			gtag('js', new Date());
			gtag('config', 'G-CR2JJD19S0');
		</script>

		<title>Zhongmu</title>

		<meta charset="utf-8" />

		<link type="text/css" rel="stylesheet" href="{{ .root }}/zm.css?v={{ .version }}"   />
		<link type="text/css" rel="stylesheet" href="{{ .root }}/show.css?v={{ .version }}" />

		<script src="{{ .root }}/pako.min.js?v={{ .version }}"></script>
		<script src="{{ .root }}/full.js?v={{ .version }}"></script>

		<meta name="description" content="Chinese character deep recursive inspection" />
		<meta name="robots" content="index, archive" />
		<meta name="keywords" content="Chinese language, character decomposition, San Bai Qian">
		<meta name="author" content="Mathieu Bivert" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	</head>
	<body>
		<div id="loading"><span id="loading-wheel"></span></div>

		<div id="content">
			<div id="header">
				<div id="menu">
					<ul>
						<li><a href="{{ .root }}/index.html">üè†</a></li>
						<li><a href="{{ .root }}/books.html">Books</a></li>
						<li><a href="{{ .root }}/help.html">Help</a></li>
						<li><a href="{{ .root }}/about.html">About</a></li>
					</ul>
				</div>
				<div id="important">
					You may want to
					<a href="https://organharvestinvestigation.net/">document</a>
					yourself about human rights in China.
				</div>
			</div>
			<script>window.addEventListener('load', function() {
				SPA.init(window.location.pathname);
			});</script>
			<div id="main"></div>
			<div id="footer">
				<p>
					¬© Last update: 2024-07-11 - WIP -
					<a href="https://github.com/mbivert/zm/">code</a> -
					<a href="https://github.com/mbivert/zm-data/">data</a>;
					optimized for desktop</p>
			</div>
		</div>
	</body>
</html>
`));

var port     string
var usock    string
var dir      string
var fastcgi  bool
var configFn string
var openbsd  bool

func init() {
	flag.StringVar(&port,  "p", ":8001", "TCP address to listen to")
	flag.StringVar(&dir,   "d", "./site-ready/", "HTTP root location")
	flag.StringVar(&usock, "u", "", "If set, listen on unix socket over TCP port")
	flag.BoolVar(&fastcgi, "f", false, "If set, use the UNIX socket and FastCGI")
	flag.StringVar(&configFn, "c", "config.json", "/path/to/config.json")
	flag.BoolVar(&openbsd, "o", false, "Tweaks for OpenBSD")

	flag.Parse();

	data, err := os.ReadFile(configFn)
	if err != nil {
		log.Fatal("Cannot read '"+configFn+"': ", err)
	}

	if err := json.Unmarshal(data, &C); err != nil {
		log.Fatal("Error while parsing '"+configFn+"': ", err)
	}
}

func isDir(path string) (bool, error) {
	fi, err := os.Stat(path)
	if err != nil {
		return false, err
	}

	return fi.IsDir(), nil
}

func main() {
	// Won't change
	var s strings.Builder
	indexPageTmpl.Execute(&s, map[string]any{
		"root"    : C.Root,
		"version" : C.Version,
	})

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		path := filepath.Clean(r.URL.Path)
		log.Println("Request to "+path)
		if path == "/" {
			path = "/index.html"
		}
		fpath := filepath.Join(dir, path)
		isdir, err := isDir(fpath)
		if isdir || err != nil {
			path = "index.html"
		}

		if strings.HasSuffix(path, ".html") {
			// Should barely ever happen
			if _, err := io.WriteString(w, s.String()); err != nil {
				log.Println(err)
			}
		} else {
			http.ServeFile(w, r, fpath)
		}
	})

	if usock != "" {
		// This isn't needed on Linux thanks to the proper socket closing
		// which follows, but that dance doesn't appease the OpenBSD go^wdaemons,
		// so we must remove it (otherwise, fails with a "bind: address already in use")
		if openbsd {
		if err := os.RemoveAll(usock); err != nil {
			log.Fatal(err)
		}}

		l, err := net.Listen("unix", usock)
		if err != nil {
			log.Fatal(err)
		}

		// NOTE: the socket needs to be properly closed on exit, for
		// otherwise, it'll stay bound. In production, it becomes tricky
		// to simply remove the socket before starting.
		//
		// https://stackoverflow.com/a/16702173
		sigc := make(chan os.Signal, 1)
		signal.Notify(sigc, os.Interrupt, os.Kill, syscall.SIGTERM)
		go func(c chan os.Signal) {
			// Wait for a SIGINT or SIGKILL:
			sig := <-c
			log.Printf("Caught signal %s: shutting down.", sig)
			// Stop listening (and unlink the socket if unix type):
			l.Close()
			os.Exit(0)
		}(sigc)

		log.Printf("Listening on unix:%s (fastcgi: %t)\n", usock, fastcgi);

		if fastcgi {
			log.Fatal(fcgi.Serve(l, nil))
		} else {
			log.Fatal(http.Serve(l, nil))
		}
	} else {
		log.Println("Listening on "+port)
		log.Fatal(http.ListenAndServe(port, nil))
	}
}
