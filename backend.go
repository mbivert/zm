package main

/*
 * We need at least a basic backend to serve both our
 * single page (SPA) and data files/CSS/images/etc.
 *
 * We'll later extend this to build our authentication.
 *
 * For now, the configuration (config.json) is somewhat
 * clumsily generated by bin/mkconfigjs.sh.
 */

import (
	"encoding/json"
	"flag"
	"html/template"
	"io"
	"log"
	"net"
	"net/http"
	"net/http/fcgi"
	"os"
	"path/filepath"
	"strings"
	"os/signal"
	"syscall"
	"github.com/mbivert/auth"
//	"compress/gzip"
	"fmt"
//	"io/fs"
)

type Config struct {
	Version string `json:"version"`
	Root    string `json:"root"`
}

var C Config

var indexPageTmpl = template.Must(template.New("").Parse(""+
`<!DOCTYPE html>
<html>
	<head>
		<!-- Google tag (gtag.js) -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-CR2JJD19S0"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag(){dataLayer.push(arguments);}
			gtag('js', new Date());
			gtag('config', 'G-CR2JJD19S0');
		</script>

		<title>Zhongmu</title>

		<meta charset="utf-8" />

		<link type="text/css" rel="stylesheet" href="{{ .root }}/zm.css?v={{ .version }}"   />
		<link type="text/css" rel="stylesheet" href="{{ .root }}/show.css?v={{ .version }}" />

		<script src="{{ .root }}/pako.min.js?v={{ .version }}"></script>
		<script src="{{ .root }}/full.js?v={{ .version }}"></script>

		<meta name="description" content="Chinese character deep recursive inspection" />
		<meta name="robots" content="index, archive" />
		<meta name="keywords" content="Chinese language, character decomposition, San Bai Qian">
		<meta name="author" content="Mathieu Bivert" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	</head>
	<body>
		<div id="loading"><span id="loading-wheel"></span></div>

		<div id="content">
			<div id="header">
				<div id="menu">
					<ul>
						<li><a href="{{ .root }}/index.html">üè†</a></li>
						<li><a href="{{ .root }}/books.html">Books</a></li>
						<li><a href="{{ .root }}/help.html">Help</a></li>
						<li><a href="{{ .root }}/about.html">About</a></li>
						<li><a href="{{ .root }}/login.html">Login</a></li>
					</ul>
				</div>
				<div id="important">
					You may want to
					<a href="https://organharvestinvestigation.net/">document</a>
					yourself about human rights in China.
				</div>
			</div>
			<script>window.addEventListener('load', function() {
				SPA.init(window.location.pathname);
			});</script>
			<div id="main"></div>
			<div id="footer">
				<p>
					¬© Last update: 2024-07-28 - WIP -
					<a href="https://github.com/mbivert/zm/">code</a> -
					<a href="https://github.com/mbivert/zm-data/">data</a>;
					optimized for desktop</p>
			</div>
		</div>
	</body>
</html>
`));

var port     string
var usock    string
var dir      string
var fastcgi  bool
var configFn string
var openbsd  bool

func init() {
	flag.StringVar(&port,  "p", ":8001", "TCP address to listen to")
	flag.StringVar(&dir,   "d", "./site-ready/", "HTTP root location")
	flag.StringVar(&usock, "u", "", "If set, listen on unix socket over TCP port")
	flag.BoolVar(&fastcgi, "f", false, "If set, use the UNIX socket and FastCGI")
	flag.StringVar(&configFn, "c", "config.json", "/path/to/config.json")
	flag.BoolVar(&openbsd, "o", false, "Tweaks for OpenBSD")

	flag.Parse();

	data, err := os.ReadFile(configFn)
	if err != nil {
		log.Fatal("Cannot read '"+configFn+"': ", err)
	}

	if err := json.Unmarshal(data, &C); err != nil {
		log.Fatal("Error while parsing '"+configFn+"': ", err)
	}
}

func isDir(path string) (bool, error) {
	fi, err := os.Stat(path)
	if err != nil {
		return false, err
	}

	return fi.IsDir(), nil
}

type OurFSContext struct{
	db *DB
}

func (*OurFSContext) Root() string {
	return dir
}

func (*OurFSContext) IsValidToken(tok string) (bool, auth.UserId, error) {
	return auth.IsValidToken(tok)
}

func (ctx *OurFSContext) CanGet(uid auth.UserId, path string) (bool, error) {
	// XXX clumsy I guess
	path, _ = filepath.Rel(ctx.Root(), path)
	return ctx.db.CanGet(uid, path)
}

func (*OurFSContext) CanSet(uid auth.UserId, path, data string) (bool, error) {
	return false, nil
}

// fancy
func wrap[Tin, Tout any](
	db *DB, f func(db *DB, in *Tin, out *Tout) error,
) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		var in Tin
		var out Tout

		r.Body = http.MaxBytesReader(w, r.Body, 1048576)
		err := json.NewDecoder(r.Body).Decode(&in)
		if err != nil {
			log.Println(err)
			err = fmt.Errorf("JSON decoding failure")
			goto err
		}

		err = f(db, &in, &out)
		if err != nil {
			goto err
		}

		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		err = json.NewEncoder(w).Encode(out)

		if err != nil {
			log.Println(err)
			err = fmt.Errorf("JSON encoding failure")
			goto err
		}

		return

	err:
		fails(w, err)
		return
	}
}

type DataType string

// XXX we have it 3 times now: JS, Go, SQL
const (
	dataTDict DataType = "dict"
	dataTDecomp        = "decomp"
	dataTBig5          = "big5"
	dataTBook          = "book"
	dataTPieces        = "pieces"
)

type DataFmt string

const (
	dataFCCCEdict DataFmt = "cc-cedict"
	dataFWMDecomp         = "wm-decomp"
	dataFChise            = "chise"
	dataFUnicodeBig5      = "unicode-big5"
	dataFMarkdown         = "markdown"
	dataFSWMarkdown       = "sw-markdown"
	dataFSimpleDict       = "simple-dict"
	dataFPieces           = "pieces"
)

type DataSetIn struct {
	Token     string   // `json:"token"`
	Name      string   // `json:"name"`
	Type      DataType // `json:"type"`
	Descr     string   // `json:"descr"`
	Fmt       DataFmt  // `json:"fmt"`

	Public    bool     // `json:"public"`
	LicenseId int64    // `json:"licenseid"`

	// XXX We at least would want to check that
	// this looks like a URL
	// rename to url?
	UrlInfo   string   // `json:"urlinfo"`

	// Okay, we'll do that for now, this should be
	// good enough for a first draft, and small documents.
	Content   string   // `json:"content"`

	// This two are automatically computed
	File      string
	UserId    auth.UserId
}

type DataSetOut struct {
}

func DataSet(db *DB, in *DataSetIn, out *DataSetOut) error {
	fmt.Println(in)
	ok, uid, err := auth.IsValidToken(in.Token)
	if err != nil {
		return err
	}
	if !ok {
		return fmt.Errorf("Not connected!")
	}

	in.File = fmt.Sprintf("data/%d/%s", uid, "mayberandombits")
	in.UserId = uid

	if err := db.AddData(in); err != nil {
		return err
	}

	// TODO: write in.Content to in.File
	return nil
}

func main() {
	// Won't change
	var s strings.Builder
	indexPageTmpl.Execute(&s, map[string]any{
		"root"    : C.Root,
		"version" : C.Version,
	})

	// TODO: this should be in the Config
	fn   := "db-dev.sqlite"

	db, err := NewDB(fn)
	if err != nil {
		log.Fatal(err)
	}

	if err := auth.LoadConf("config.auth.json"); err != nil {
		log.Fatal(err)
	}

	http.Handle("/auth/", http.StripPrefix("/auth", auth.New(db)))

	http.HandleFunc("/data/set", wrap[DataSetIn, DataSetOut](db, DataSet))

	// Keep the prefix: the files are still located in a data/ directory
	http.Handle("/data/", NewFS(&OurFSContext{db}))

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		path := filepath.Clean(r.URL.Path)
		log.Println("Request to "+path)
		if path == "/" {
			path = "/index.html"
		}
		fpath := filepath.Join(dir, path)
		isdir, err := isDir(fpath)
		if isdir || err != nil {
			path = "index.html"
		}

		// rough guard: this shouldn't happen anymore
		if strings.HasPrefix(path, "/data/") {
			w.WriteHeader(http.StatusBadRequest)
		}

		if strings.HasSuffix(path, ".html") {
			// Should barely ever happen
			if _, err := io.WriteString(w, s.String()); err != nil {
				log.Println(err)
			}
		} else {
			fmt.Println("HandleFunc /: "+fpath)
			http.ServeFile(w, r, fpath)
		}
	})

	if usock != "" {
		// This isn't needed on Linux thanks to the proper socket closing
		// which follows, but that dance doesn't appease the OpenBSD go^wdaemons,
		// so we must remove it (otherwise, fails with a "bind: address already in use")
		if openbsd {
		if err := os.RemoveAll(usock); err != nil {
			log.Fatal(err)
		}}

		l, err := net.Listen("unix", usock)
		if err != nil {
			log.Fatal(err)
		}

		// NOTE: the socket needs to be properly closed on exit, for
		// otherwise, it'll stay bound. In production, it becomes tricky
		// to simply remove the socket before starting.
		//
		// https://stackoverflow.com/a/16702173
		sigc := make(chan os.Signal, 1)
		signal.Notify(sigc, os.Interrupt, os.Kill, syscall.SIGTERM)
		go func(c chan os.Signal) {
			// Wait for signal/interrupt
			sig := <-c
			log.Printf("Caught signal %s: shutting down.", sig)
			l.Close()
			os.Exit(0)
		}(sigc)

		log.Printf("Listening on unix:%s (fastcgi: %t)\n", usock, fastcgi);

		if fastcgi {
			log.Fatal(fcgi.Serve(l, nil))
		} else {
			log.Fatal(http.Serve(l, nil))
		}
	} else {
		log.Println("Listening on "+port)
		log.Fatal(http.ListenAndServe(port, nil))
	}
}
